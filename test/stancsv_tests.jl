using MCMCChains
using CSV
using Test

@testset "CSV and StanCSV Serialization" begin

    @testset "Simple CSV via Tables.jl" begin
        chn = Chains(randn(50, 3, 2), [:a, :b, :c])

        mktempdir() do tmpdir
            f = joinpath(tmpdir, "chain.csv")
            CSV.write(f, chn)
            chn2 = Chains(CSV.File(f))
            @test :a in names(chn2)
            @test :b in names(chn2)
            @test :c in names(chn2)
            @test :iteration ∉ names(chn2)
            @test :chain ∉ names(chn2)
            @test size(chn2, 3) == size(chn, 3)
            @test chn2.value.data ≈ chn.value.data
        end
    end

    @testset "Parameter Name Conversion" begin
        @testset "to_stan: theta[1] → theta.1" begin
            chn = Chains(randn(10, 3, 1), [Symbol("x[1]"), Symbol("y[1,2]"), :z])
            mktempdir() do tmpdir
                f = joinpath(tmpdir, "out.csv")
                write_stancsv(f, chn; include_adaptation = false, include_timing = false)
                header = readline(f)
                @test contains(header, "x.1")
                @test contains(header, "y.1.2")
                @test contains(header, "z")
                @test !contains(header, "[")
            end
        end

        @testset "from_stan: theta.1 → theta[1]" begin
            stan_csv = "lp__,theta.1,beta.2.3\n-1.0,0.5,1.5\n-2.0,0.6,1.6"
            mktempdir() do tmpdir
                f = joinpath(tmpdir, "stan.csv")
                write(f, stan_csv)
                chn = read_stancsv(f)
                @test Symbol("theta[1]") in names(chn)
                @test Symbol("beta[2,3]") in names(chn)
            end
        end
    end

    @testset "Column Ordering" begin
        chn = Chains(
            randn(10, 4, 1),
            [:mu, :sigma, :lp__, :accept_stat__],
            Dict(:internals => [:lp__, :accept_stat__]),
        )
        mktempdir() do tmpdir
            f = joinpath(tmpdir, "out.csv")
            write_stancsv(f, chn; include_adaptation = false, include_timing = false)
            header = readline(f)
            lp_pos = findfirst("lp__", header)
            mu_pos = findfirst("mu", header)
            @test lp_pos.start < mu_pos.start
        end
    end

    @testset "Internals Classification" begin
        stan_csv = "lp__,accept_stat__,theta,sigma\n-1.0,0.9,0.5,1.0"
        mktempdir() do tmpdir
            f = joinpath(tmpdir, "stan.csv")
            write(f, stan_csv)
            chn = read_stancsv(f)
            @test :lp__ in chn.name_map.internals
            @test :accept_stat__ in chn.name_map.internals
            @test :theta in chn.name_map.parameters
            @test :sigma in chn.name_map.parameters
        end
    end

    @testset "Round Trip Data Integrity" begin
        val = randn(20, 3, 1)
        chn = Chains(val, [:a, :b, :c])
        mktempdir() do tmpdir
            f = joinpath(tmpdir, "rt.csv")
            write_stancsv(f, chn; include_adaptation = false, include_timing = false)
            chn2 = read_stancsv(f)
            @test Array(chn[:, :a, 1]) ≈ Array(chn2[:, :a, 1])
            @test Array(chn[:, :b, 1]) ≈ Array(chn2[:, :b, 1])
        end
    end

    @testset "Multi-chain Export" begin
        chn = Chains(randn(10, 2, 3), [:a, :b])
        mktempdir() do tmpdir
            base = joinpath(tmpdir, "chain.csv")
            files = write_stancsv(
                base,
                chn,
                Val(:all);
                include_adaptation = false,
                include_timing = false,
            )
            @test length(files) == 3
            for f in files
                @test isfile(f)
            end
        end
    end

    @testset "Multi-chain Read" begin
        chn = Chains(randn(10, 2, 2), [:a, :b])
        mktempdir() do tmpdir
            f1 = joinpath(tmpdir, "c1.csv")
            f2 = joinpath(tmpdir, "c2.csv")
            write_stancsv(
                f1,
                chn;
                chain_id = 1,
                include_adaptation = false,
                include_timing = false,
            )
            write_stancsv(
                f2,
                chn;
                chain_id = 2,
                include_adaptation = false,
                include_timing = false,
            )
            chn2 = read_stancsv([f1, f2])
            @test size(chn2, 3) == 2
        end
    end

    @testset "Real CmdStan Output" begin
        # Fixture generated by CmdStan v2.38.0 (NUTS sampler, 50 post-warmup draws).
        # The StanCSV format may change in future CmdStan versions.
        # If the functionality breaks after a CmdStan upgrade, please report it.
        fixture = joinpath(@__DIR__, "fixtures", "cmdstan_output.csv")
        chn = read_stancsv(fixture)

        @test chn.info.model_name == "test_model_model"
        @test chn.info.seed == 42
        @test chn.info.stepsize ≈ 0.486381 atol=1e-4
        @test chn.info.num_warmup == 100

        @test size(chn, 1) == 50
        @test size(chn, 3) == 1

        all_names = names(chn)
        @test :lp__ in all_names
        @test :accept_stat__ in all_names
        @test :stepsize__ in all_names
        @test :alpha in all_names
        @test :sigma in all_names
        for i = 1:3
            @test Symbol("beta[$i]") in all_names
        end
        for i = 1:2
            @test Symbol("gamma[$i]") in all_names
        end
        for c = 1:3, r = 1:2
            @test Symbol("mat_param[$r,$c]") in all_names
        end

        @test :lp__ in chn.name_map.internals
        @test :accept_stat__ in chn.name_map.internals
        @test :alpha in chn.name_map.parameters
        @test Symbol("beta[1]") in chn.name_map.parameters
        @test Symbol("mat_param[1,1]") in chn.name_map.parameters
    end

    @testset "StanCSV Round-Trip Fidelity" begin
        # Write the real CmdStan output back to StanCSV and re-read it.
        fixture = joinpath(@__DIR__, "fixtures", "cmdstan_output.csv")
        chn = read_stancsv(fixture)

        mktempdir() do tmpdir
            rewritten = joinpath(tmpdir, "rewritten.csv")
            write_stancsv(
                rewritten,
                chn;
                include_adaptation = false,
                include_timing = false,
            )
            chn2 = read_stancsv(rewritten)

            @test names(chn2) == names(chn)
            @test size(chn2) == size(chn)

            for col in names(chn)
                @test Array(chn[:, col, 1]) ≈ Array(chn2[:, col, 1])
            end

            @test :lp__ in chn2.name_map.internals
            @test :accept_stat__ in chn2.name_map.internals
            @test :alpha in chn2.name_map.parameters
            @test Symbol("beta[1]") in chn2.name_map.parameters
            @test Symbol("mat_param[1,1]") in chn2.name_map.parameters
        end
    end

    @testset "Adaptation Comments" begin
        chn = Chains(randn(5, 2, 1), [:a, :b])
        mktempdir() do tmpdir
            f = joinpath(tmpdir, "out.csv")
            write_stancsv(f, chn; include_timing = false)
            content = read(f, String)
            @test contains(content, "# Adaptation terminated")
            @test contains(content, "# Diagonal elements")
        end
    end

    @testset "Timing Comments" begin
        chn = Chains(randn(5, 2, 1), [:a, :b])
        mktempdir() do tmpdir
            f = joinpath(tmpdir, "out.csv")
            write_stancsv(f, chn; include_adaptation = false)
            content = read(f, String)
            @test contains(content, "Elapsed Time")
        end
    end

    @testset "No Comments Mode" begin
        chn = Chains(randn(5, 2, 1), [:a, :b])
        mktempdir() do tmpdir
            f = joinpath(tmpdir, "out.csv")
            write_stancsv(f, chn; include_adaptation = false, include_timing = false)
            content = read(f, String)
            @test !startswith(content, "#")
            @test startswith(content, "a") || startswith(content, "b")
        end
    end
end
