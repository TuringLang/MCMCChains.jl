var documenterSearchIndex = {"docs":
[{"location":"getting-started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/#Chains-type","page":"Getting started","title":"Chains type","text":"","category":"section"},{"location":"getting-started/#MCMCChains.Chains","page":"Getting started","title":"MCMCChains.Chains","text":"Chains\n\nParameters:\n\nvalue: An AxisArray object with axes iter × var × chains\nlogevidence : A field containing the logevidence.\nname_map : A NamedTuple mapping each variable to a section.\ninfo : A NamedTuple containing miscellaneous information relevant to the chain.\n\nThe info field can be set using setinfo(c::Chains, n::NamedTuple).\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#Indexing-and-parameter-Names","page":"Getting started","title":"Indexing and parameter Names","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Chains can be constructed with parameter names. For example, to create a chains object with","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"500 samples,\n2 parameters (named a and b)\n3 chains","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"use","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"using MCMCChains # hide\nusing Random # hide\nRandom.seed!(0) # hide\nval = rand(500, 2, 3)\nchn = Chains(val, [:a, :b])","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"By default, parameters will be given the name param_i, where i is the parameter number:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"chn = Chains(rand(100, 2, 2))","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We can set and get indexes for parameter 2:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"chn_param2 = chn[1:5,2,:];","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"chn[:,2,:] = fill(4, 100, 1, 2)\nchn","category":"page"},{"location":"getting-started/#Rename-Parameters","page":"Getting started","title":"Rename Parameters","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Parameter names can be changed with the function replacenames:","category":"page"},{"location":"getting-started/#MCMCChains.replacenames","page":"Getting started","title":"MCMCChains.replacenames","text":"replacenames(chains::Chains, dict::AbstractDict)\n\nReplace parameter names by creating a new Chains object that shares the same underlying data.\n\nExamples\n\njulia> chn = Chains(rand(100, 2, 2), [\"one\", \"two\"]);\n\njulia> chn2 = replacenames(chn, \"one\" => \"A\");\n\njulia> names(chn2)\n2-element Vector{Symbol}:\n :A\n :two\n\njulia> chn3 = replacenames(chn2, Dict(\"A\" => \"one\", \"two\" => \"B\"));\n\njulia> names(chn3) \n2-element Vector{Symbol}:\n :one\n :B\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#Sections","page":"Getting started","title":"Sections","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Chains parameters are sorted into sections that represent groups of parameters, see  MCMCChains.group. By default, every chain contains a parameters section, to which all unassigned parameters are assigned to. Chains can be assigned a named map during construction:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"chn = Chains(rand(100, 4, 2), [:a, :b, :c, :d])","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The MCMCChains.set_section function returns a new Chains object:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"chn2 = set_section(chn, Dict(:internals => [:c, :d]))","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Note that only a and b are being shown. You can explicity retrieve an array of the summary statistics and the quantiles of the :internals section by calling describe(chn; sections = :internals), or of all variables with describe(chn; sections = nothing). Many functions such as MCMCChains.summarize support the sections keyword argument.","category":"page"},{"location":"getting-started/#Groups-of-parameters","page":"Getting started","title":"Groups of parameters","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"You can access the names of all parameters in a chain that belong to the group name by using","category":"page"},{"location":"getting-started/#MCMCChains.namesingroup","page":"Getting started","title":"MCMCChains.namesingroup","text":"namesingroup(chains::Chains, sym::Union{AbstractString,Symbol}; index_type::Symbol=:bracket)\n\nReturn the parameters with the same name sym, but have a different index. Bracket indexing format in the form of :sym[index] is assumed by default. Use index_type=:dot for parameters with dot  indexing, i.e. :sym.index.\n\nIf the chain contains a parameter of name :sym it will be returned as well.\n\nExample\n\njulia> chn = Chains(rand(100, 2, 2), [\"A[1]\", \"A[2]\"]);\n\njulia> namesingroup(chn, :A)\n2-element Vector{Symbol}:\n Symbol(\"A[1]\")\n Symbol(\"A[2]\")\n\njulia> # Also works for specific elements.\n       namesingroup(chn, Symbol(\"A[1]\"))\n1-element Vector{Symbol}:\n Symbol(\"A[1]\")\n\n\njulia> chn = Chains(rand(100, 3, 2), [\"A.1\", \"A.2\", \"B\"]);\n\njulia> namesingroup(chn, :A; index_type=:dot)\n2-element Vector{Symbol}:\n Symbol(\"A.1\")\n Symbol(\"A.2\")\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#The-get-Function","page":"Getting started","title":"The get Function","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"MCMCChains also provides a get function designed to make it easier to access parameters:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"using MCMCChains # hide\nval = rand(6, 3, 1)\nchn = Chains(val, [:a, :b, :c]);\n\nx = get(chn, :a)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"You can also access the variables via getproperty:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"x.a","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"get also accepts vectors of things to retrieve, so you can call ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"x = get(chn, [:a, :b])","category":"page"},{"location":"getting-started/#Saving-and-Loading-Chains","page":"Getting started","title":"Saving and Loading Chains","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Like any Julia object, a Chains object can be saved using Serialization.serialize and loaded back by Serialization.deserialize as identical as possible. Note, however, that in general this process will not work if the reading and writing are done by different versions of Julia, or an instance of Julia with a different system image. You might want to consider JLSO for saving metadata such as the Julia version and the versions of all packages installed as well.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"using Serialization\n\nserialize(\"chain-file.jls\", chn)\nchn2 = deserialize(\"chain-file.jls\")","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The MCMCChainsStorage.jl package also provides the ability to serialize/deserialize a chain to an HDF5 file across different versions of Julia and/or different system images.","category":"page"},{"location":"getting-started/#Exporting-Chains","page":"Getting started","title":"Exporting Chains","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"A few utility export functions have been provided to convert Chains objects to either an Array or a DataFrame:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"using MCMCChains # hide\n\nchn = Chains(rand(3, 2, 2), [:a, :b])\n\nArray(chn)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Array(chn, [:parameters])","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"By default chains are appended. This can be disabled by using the append_chains keyword  argument:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"A = Array(chn, append_chains=false)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"which will return a matrix for each chain. For example, for the second chain:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"A[2]","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Similarly, for DataFrames:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"using DataFrames\n\nDataFrame(chn)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"See also ?DataFrame and ?Array for more help.","category":"page"},{"location":"getting-started/#Sampling-Chains","page":"Getting started","title":"Sampling Chains","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"MCMCChains overloads several sample methods as defined in StatsBase:","category":"page"},{"location":"getting-started/#StatsBase.sample-Tuple{Chains, Integer}","page":"Getting started","title":"StatsBase.sample","text":"sample([rng,] chn::Chains, [wv::AbstractWeights,] n; replace=true, ordered=false)\n\nSample n samples from the pooled (!) chain chn.\n\nThe keyword arguments replace and ordered determine whether sampling is performed with replacement and whether the sample is ordered, respectively. If specified, sampling probabilities are proportional to weights wv.\n\nnote: Note\nIf chn contains multiple chains, they are pooled (i.e., appended) before sampling. This ensures that even in this case exactly n samples are returned:julia> chn = Chains(randn(11, 4, 3));\n\njulia> size(sample(chn, 7)) == (7, 4, 1)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"See ?sample for additional help on sampling. Alternatively, you can construct and sample from a kernel density estimator using KernelDensity.jl, see test/sampling_tests.jl.","category":"page"},{"location":"chains/#Chains","page":"Chains","title":"Chains","text":"","category":"section"},{"location":"chains/","page":"Chains","title":"Chains","text":"The methods listed below are defined in src/chains.jl.","category":"page"},{"location":"chains/#MCMCChains.Chains-Tuple{Chains, Union{AbstractString, Symbol}}","page":"Chains","title":"MCMCChains.Chains","text":"Chains(c::Chains, section::Union{Symbol,AbstractString})\nChains(c::Chains, sections)\n\nReturn a new chain with only a specific section or multiple sections pulled out.\n\nExamples\n\njulia> chn = Chains(rand(100, 2, 1), [:a, :b], Dict(:internals => [:a]));\n\njulia> names(chn)\n2-element Vector{Symbol}:\n :a\n :b\n\njulia> chn2 = Chains(chn, :internals);\n\njulia> names(chn2)\n1-element Vector{Symbol}:\n :a\n\n\n\n\n\n","category":"method"},{"location":"chains/#Base.get-Tuple{Chains, Vector{Symbol}}","page":"Chains","title":"Base.get","text":"Base.get(c::Chains, v::Symbol; flatten=false)\nBase.get(c::Chains, vs::Vector{Symbol}; flatten=false)\n\nReturn a NamedTuple with v as the key, and matching parameter names as the values.\n\nPassing flatten=true will return a NamedTuple with keys ungrouped.\n\nExample\n\njulia> chn = Chains([1:2 3:4]);\n\njulia> get(chn, :param_1)\n(param_1 = [1; 2;;],)\n\njulia> get(chn, [:param_2])\n(param_2 = [3; 4;;],)\n\njulia> get(chn, :param_1; flatten=true)\n(param_1 = 1,)\n\n\n\n\n\n","category":"method"},{"location":"chains/#Base.get-Tuple{Chains}","page":"Chains","title":"Base.get","text":"get(c::Chains; section::Union{Symbol,AbstractVector{Symbol}}, flatten=false)\n\nReturn all parameters in a given section(s) as a NamedTuple.\n\nPassing flatten=true will return a NamedTuple with keys ungrouped.\n\nExample\n\njulia> chn = Chains([1:2 3:4], [:a, :b], Dict(:internals => [:a]));\n\njulia> get(chn; section=:parameters)\n(b = [3; 4;;],)\n\njulia> get(chn; section=[:internals])\n(a = [1; 2;;],)\n\n\n\n\n\n","category":"method"},{"location":"chains/#Base.names-Tuple{Chains, Any}","page":"Chains","title":"Base.names","text":"names(chains::Chains, sections)\n\nReturn the parameter names of the sections in the chains.\n\n\n\n\n\n","category":"method"},{"location":"chains/#Base.names-Tuple{Chains, Symbol}","page":"Chains","title":"Base.names","text":"names(chains::Chains, section::Symbol)\n\nReturn the parameter names of a section in the chains.\n\n\n\n\n\n","category":"method"},{"location":"chains/#Base.names-Tuple{Chains}","page":"Chains","title":"Base.names","text":"names(chains::Chains)\n\nReturn the parameter names in the chains.\n\n\n\n\n\n","category":"method"},{"location":"chains/#Base.range-Tuple{Chains}","page":"Chains","title":"Base.range","text":"range(chains::Chains)\n\nReturn the range of iteration indices of the chains.\n\n\n\n\n\n","category":"method"},{"location":"chains/#Base.sort-Tuple{Chains}","page":"Chains","title":"Base.sort","text":"sort(c::Chains[; lt=NaturalSort.natural])\n\nReturn a new column-sorted version of c.\n\nBy default the columns are sorted in natural sort order.\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.chains-Tuple{Chains}","page":"Chains","title":"MCMCChains.chains","text":"chains(c::Chains)\n\nReturn the names or symbols of each chain in a Chains object.\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.compute_duration-Tuple{Chains}","page":"Chains","title":"MCMCChains.compute_duration","text":"compute_duration(c::Chains; start=start_times(c), stop=stop_times(c))\n\nCalculate the compute time for all chains in seconds.\n\nThe duration is calculated as the sum of start - stop in seconds. \n\ncompute_duration is more useful in cases of parallel sampling, where wall_duration may understate how much computation time was utilitzed.\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.get_params-Tuple{Chains}","page":"Chains","title":"MCMCChains.get_params","text":"get_params(c::Chains; flatten=false)\n\nReturn all parameters packaged as a NamedTuple. Variables with a bracket in their name (as in \"P[1]\") will be grouped into the returned value as P.\n\nPassing flatten=true will return a NamedTuple with keys ungrouped.\n\nExample\n\njulia> chn = Chains(1:5);\n\njulia> x = get_params(chn);\n\njulia> x.param_1\n2-dimensional AxisArray{Int64,2,...} with axes:\n    :iter, 1:1:5\n    :chain, 1:1\nAnd data, a 5×1 Matrix{Int64}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.get_sections","page":"Chains","title":"MCMCChains.get_sections","text":"get_sections(chains[, sections])\n\nReturn multiple Chains objects, each containing only a single section.\n\n\n\n\n\n","category":"function"},{"location":"chains/#MCMCChains.group-Tuple{Chains, Union{AbstractString, Symbol}}","page":"Chains","title":"MCMCChains.group","text":"group(chains::Chains, name::Union{AbstractString,Symbol}; index_type::Symbol=:bracket)\n\nReturn a subset of the chain containing parameters with the same name, but a different index.\n\nBracket indexing format in the form of :name[index] is assumed by default. Use index_type=:dot for parameters with dot  indexing, i.e. :sym.index.\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.header-Tuple{Chains}","page":"Chains","title":"MCMCChains.header","text":"header(c::Chains; section=missing)\n\nReturn a string containing summary information for a Chains object. If the section keyword is used, this function prints only the relevant section header.\n\nExample\n\n# Printing the whole header.\nheader(chn)\n\n# Print only one section's header.\nheader(chn, section = :parameter)\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.max_stop-Tuple{Chains}","page":"Chains","title":"MCMCChains.max_stop","text":"max_stop(c::Chains)\n\nRetrieve the maximum of the stop times (as DateTime) from chain.info.\n\nIt is assumed that the start times are stored in chain.info.stop_time as DateTime or unix timestamps of type Float64.\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.min_start-Tuple{Chains}","page":"Chains","title":"MCMCChains.min_start","text":"min_start(c::Chains)\n\nRetrieve the minimum of the start times (as DateTime) from chain.info.\n\nIt is assumed that the start times are stored in chain.info.start_time as DateTime or unix timestamps of type Float64.\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.namesingroup-Tuple{Chains, AbstractString}","page":"Chains","title":"MCMCChains.namesingroup","text":"namesingroup(chains::Chains, sym::Union{AbstractString,Symbol}; index_type::Symbol=:bracket)\n\nReturn the parameters with the same name sym, but have a different index. Bracket indexing format in the form of :sym[index] is assumed by default. Use index_type=:dot for parameters with dot  indexing, i.e. :sym.index.\n\nIf the chain contains a parameter of name :sym it will be returned as well.\n\nExample\n\njulia> chn = Chains(rand(100, 2, 2), [\"A[1]\", \"A[2]\"]);\n\njulia> namesingroup(chn, :A)\n2-element Vector{Symbol}:\n Symbol(\"A[1]\")\n Symbol(\"A[2]\")\n\njulia> # Also works for specific elements.\n       namesingroup(chn, Symbol(\"A[1]\"))\n1-element Vector{Symbol}:\n Symbol(\"A[1]\")\n\n\njulia> chn = Chains(rand(100, 3, 2), [\"A.1\", \"A.2\", \"B\"]);\n\njulia> namesingroup(chn, :A; index_type=:dot)\n2-element Vector{Symbol}:\n Symbol(\"A.1\")\n Symbol(\"A.2\")\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.replacenames-Tuple{Chains, AbstractDict}","page":"Chains","title":"MCMCChains.replacenames","text":"replacenames(chains::Chains, dict::AbstractDict)\n\nReplace parameter names by creating a new Chains object that shares the same underlying data.\n\nExamples\n\njulia> chn = Chains(rand(100, 2, 2), [\"one\", \"two\"]);\n\njulia> chn2 = replacenames(chn, \"one\" => \"A\");\n\njulia> names(chn2)\n2-element Vector{Symbol}:\n :A\n :two\n\njulia> chn3 = replacenames(chn2, Dict(\"A\" => \"one\", \"two\" => \"B\"));\n\njulia> names(chn3) \n2-element Vector{Symbol}:\n :one\n :B\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.resetrange-Tuple{Chains}","page":"Chains","title":"MCMCChains.resetrange","text":"resetrange(chains::Chains)\n\nGenerate a new chain from chains with iterations indexed by 1:n, where n is the number of samples per chain.\n\nThe new chain and chains share the same data in memory.\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.sections-Tuple{Chains}","page":"Chains","title":"MCMCChains.sections","text":"sections(c::Chains)\n\nRetrieve a list of the sections in a chain.\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.set_section-Tuple{Chains, Any}","page":"Chains","title":"MCMCChains.set_section","text":"set_section(chains::Chains, namemap)\n\nCreate a new Chains object from chains with the provided namemap mapping of parameter names.\n\nBoth chains share the same underlying data. Any parameters in the chain that are unassigned will be placed into the :parameters section.\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.setinfo-Tuple{Chains, NamedTuple}","page":"Chains","title":"MCMCChains.setinfo","text":"setinfo(c::Chains, n::NamedTuple)\n\nReturn a new Chains object with a NamedTuple type n placed in the info field.\n\nExample\n\nnew_chn = setinfo(chn, NamedTuple{(:a, :b)}((1, 2)))\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.setrange-Tuple{Chains, AbstractVector{Int64}}","page":"Chains","title":"MCMCChains.setrange","text":"setrange(chains::Chains, range::AbstractVector{Int})\n\nGenerate a new chain from chains with iterations indexed by range.\n\nThe new chain and chains share the same data in memory.\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.start_times-Tuple{Chains}","page":"Chains","title":"MCMCChains.start_times","text":"start_times(c::Chains)\n\nRetrieve the contents of c.info.start_time, or missing if no  start_time is set.\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.stop_times-Tuple{Chains}","page":"Chains","title":"MCMCChains.stop_times","text":"stop_times(c::Chains)\n\nRetrieve the contents of c.info.stop_time, or missing if no  stop_time is set.\n\n\n\n\n\n","category":"method"},{"location":"chains/#MCMCChains.wall_duration-Tuple{Chains}","page":"Chains","title":"MCMCChains.wall_duration","text":"wall_duration(c::Chains; start=min_start(c), stop=max_stop(c))\n\nCalculate the wall clock time for all chains in seconds.\n\nThe duration is calculated as stop - start, where as default stop is the latest stopping time and start is the earliest starting time.\n\n\n\n\n\n","category":"method"},{"location":"statsplots/#StatsPlots.jl","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"MCMCChains implements many functions for plotting via StatsPlots.jl.","category":"page"},{"location":"statsplots/#Simple-example","page":"StatsPlots.jl","title":"Simple example","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"The following simple example illustrates how to use Chain to visually summarize a MCMC simulation:","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"using MCMCChains\nusing StatsPlots\n\n# Define the experiment\nn_iter = 100\nn_name = 3\nn_chain = 2\n\n# experiment results\nval = randn(n_iter, n_name, n_chain) .+ [1, 2, 3]'\nval = hcat(val, rand(1:2, n_iter, 1, n_chain))\n\n# construct a Chains object\nchn = Chains(val, [:A, :B, :C, :D])\n\n# visualize the MCMC simulation results\nplot(chn; size=(840, 600))\n# This output is used in README.md too. # hide\nfilename = \"default_plot.svg\" # hide\nsavefig(filename); nothing # hide","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"(Image: Default plot for Chains)","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"plot(chn, colordim = :parameter; size=(840, 400))","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"Note that the plot function takes the additional arguments described in the Plots.jl package.","category":"page"},{"location":"statsplots/#Mixed-density","page":"StatsPlots.jl","title":"Mixed density","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"plot(chn, seriestype = :mixeddensity)","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"Or, for all seriestypes, use the alternative shorthand syntax:","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"mixeddensity(chn)","category":"page"},{"location":"statsplots/#Trace","page":"StatsPlots.jl","title":"Trace","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"plot(chn, seriestype = :traceplot)","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"traceplot(chn)","category":"page"},{"location":"statsplots/#Running-average","page":"StatsPlots.jl","title":"Running average","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"meanplot(chn)","category":"page"},{"location":"statsplots/#Density","page":"StatsPlots.jl","title":"Density","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"density(chn)","category":"page"},{"location":"statsplots/#Histogram","page":"StatsPlots.jl","title":"Histogram","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"histogram(chn)","category":"page"},{"location":"statsplots/#Autocorrelation","page":"StatsPlots.jl","title":"Autocorrelation","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"autocorplot(chn)","category":"page"},{"location":"statsplots/#Violin","page":"StatsPlots.jl","title":"Violin","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"Violin plots are similar to box plots but also show the probability density of the data at different values, smoothed by a kernel density estimator.","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"violinplot(chn) # Plotting parameter 1 across all chains","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"violinplot(chn, 1) # Plotting parameter 1 across all chains","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"violinplot(chn, :A) # Plotting a specific parameter across all chains","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"violinplot(chn, [:C, :B, :A]) # Plotting multiple specific parameters across all chains","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"violinplot(chn, 1, colordim = :parameter) # Plotting chain 1 across all parameters","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"violinplot(chn, show_boxplot = false) # Plotting all parameters without the inner boxplot","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"You can also aggregate (pool) samples from all chains for a given parameter by using append_chains = true. This is useful when you want to visualize the overall posterior distribution without distinguishing between individual chains.","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"violinplot(chn, :A, append_chains = true) # Single parameter, all chains appended","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"violinplot(chn, append_chains = true) # All parameters, all chains appended","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"You can also use the plot function with seriestype = :violinplot or seriestype = :violin","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"plot(chn, seriestype = :violin)","category":"page"},{"location":"statsplots/#Corner","page":"StatsPlots.jl","title":"Corner","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"corner(chn)","category":"page"},{"location":"statsplots/#Energy-Plot","page":"StatsPlots.jl","title":"Energy Plot","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"The energy plot is a diagnostic tool for HMC-based samplers (like NUTS) that helps diagnose sampling efficiency by visualizing the energy and energy transition distributions. This plot requires that the chain contains the internal sampler statistics :hamiltonian_energy and :hamiltonian_energy_error.","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"# First, we generate a chain that includes the required sampler parameters.\nn_iter = 1000\nn_chain = 4\nval_params = randn(n_iter, 2, n_chain)\nval_energy = randn(n_iter, 1, n_chain) .+ 20\nval_energy_error = randn(n_iter, 1, n_chain) .* 0.5\nfull_val = hcat(val_params, val_energy, val_energy_error)\n\nparameter_names = [:a, :b, :hamiltonian_energy, :hamiltonian_energy_error]\nsection_map = (\n    parameters=[:a, :b],\n    internals=[:hamiltonian_energy, :hamiltonian_energy_error],\n)\n\nchn_energy = Chains(full_val, parameter_names, section_map)\n\n# Generate the energy plot (default is a density plot).\nenergyplot(chn_energy)","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"# The plot can also be generated as a histogram.\nenergyplot(chn_energy, kind=:histogram)","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"For plotting multiple parameters, ridgeline, forest and caterpillar plots can be useful.","category":"page"},{"location":"statsplots/#Ridgeline","page":"StatsPlots.jl","title":"Ridgeline","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"ridgelineplot(chn, [:C, :B, :A])","category":"page"},{"location":"statsplots/#Forest","page":"StatsPlots.jl","title":"Forest","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"forestplot(chn, [:C, :B, :A], hpd_val = [0.05, 0.15, 0.25])","category":"page"},{"location":"statsplots/#Caterpillar","page":"StatsPlots.jl","title":"Caterpillar","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"forestplot(chn, chn.name_map[:parameters], hpd_val = [0.05, 0.15, 0.25], ordered = true)","category":"page"},{"location":"statsplots/#Posterior-Predictive-Checks-(PPC)","page":"StatsPlots.jl","title":"Posterior Predictive Checks (PPC)","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"Posterior Predictive Checks (PPC) are essential tools for Bayesian model validation. They compare observed data with samples from the posterior predictive distribution to assess whether the model can reproduce key features of the data. Prior Predictive Checks can also be performed to evaluate prior appropriateness before seeing the data.","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"using Random\nRandom.seed!(123)\n\n# Generate posterior samples (parameters)\nn_iter = 500\nposterior_data = randn(n_iter, 2, 2)  # μ, σ parameters\nposterior_chains = Chains(posterior_data, [:μ, :σ])\n\n# Generate posterior predictive samples\nn_obs = 20\npp_data = zeros(n_iter, n_obs, 2)\nfor i in 1:n_iter, j in 1:2\n    μ = posterior_data[i, 1, j]\n    σ = abs(posterior_data[i, 2, j]) + 0.5  # Ensure positive σ\n    pp_data[i, :, j] = randn(n_obs) * σ .+ μ\nend\npp_chains = Chains(pp_data)\n\n# Generate observed data\nRandom.seed!(456)\nobserved = randn(n_obs) * 1.2 .+ 0.3\n\n# Basic posterior predictive check (density overlay)\n# Note: observed data is shown by default for posterior checks\nppcplot(posterior_chains, pp_chains, observed)","category":"page"},{"location":"statsplots/#Plot-Types","page":"StatsPlots.jl","title":"Plot Types","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"Our PPC implementation supports four main plot types:","category":"page"},{"location":"statsplots/#Density-Plots-(Default)","page":"StatsPlots.jl","title":"Density Plots (Default)","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"# Density overlay with customized transparency\nppcplot(posterior_chains, pp_chains, observed; \n        kind=:density, alpha=0.3, num_pp_samples=50)","category":"page"},{"location":"statsplots/#Histogram-Comparison","page":"StatsPlots.jl","title":"Histogram Comparison","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"# Normalized histogram comparison\nppcplot(posterior_chains, pp_chains, observed; kind=:histogram)","category":"page"},{"location":"statsplots/#Cumulative-Distribution-Functions","page":"StatsPlots.jl","title":"Cumulative Distribution Functions","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"# Empirical CDFs comparison\nppcplot(posterior_chains, pp_chains, observed; kind=:cumulative)","category":"page"},{"location":"statsplots/#Scatter-Plots-with-Jitter","page":"StatsPlots.jl","title":"Scatter Plots with Jitter","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"# Index-based scatter plot with automatic jitter for small samples\nppcplot(posterior_chains, pp_chains, observed; \n        kind=:scatter, num_pp_samples=8, jitter=0.3)","category":"page"},{"location":"statsplots/#Advanced-Styling-and-Options","page":"StatsPlots.jl","title":"Advanced Styling and Options","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"# Comprehensive customization example\nppcplot(posterior_chains, pp_chains, observed; \n        kind=:density,\n        colors=[:steelblue, :darkred, :orange],  # [predictive, observed, mean]\n        alpha=0.25,\n        observed_rug=true,      # Add rug plot for observed data\n        num_pp_samples=75,      # Limit predictive samples shown\n        mean_pp=true,           # Show predictive mean\n        legend=true,\n        random_seed=42)         # Reproducible subsampling","category":"page"},{"location":"statsplots/#Prior-Predictive-Checks","page":"StatsPlots.jl","title":"Prior Predictive Checks","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"Prior predictive checks assess whether priors generate reasonable data before observing actual data. The ppc_group parameter controls default behavior:","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"# Prior predictive check - observed data hidden by default\nppcplot(posterior_chains, pp_chains, observed; ppc_group=:prior)","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"# Prior check with observed data explicitly shown for comparison\nppcplot(posterior_chains, pp_chains, observed; \n        ppc_group=:prior, observed=true, alpha=0.4)","category":"page"},{"location":"statsplots/#Controlling-Observed-Data-Display","page":"StatsPlots.jl","title":"Controlling Observed Data Display","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"You can explicitly control whether observed data is shown regardless of the check type:","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"# Posterior check without observed data\nppcplot(posterior_chains, pp_chains, observed; \n        ppc_group=:posterior, observed=false)","category":"page"},{"location":"statsplots/#Performance-and-Sampling-Control","page":"StatsPlots.jl","title":"Performance and Sampling Control","text":"","category":"section"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"For large datasets or when you want to reduce visual clutter:","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"# Limit the number of predictive samples displayed\nppcplot(posterior_chains, pp_chains, observed; \n        num_pp_samples=25, \n        random_seed=123)  # Reproducible results","category":"page"},{"location":"statsplots/","page":"StatsPlots.jl","title":"StatsPlots.jl","text":"ppcplot(posterior_chains::Chains, posterior_predictive_chains::Chains, observed_data::Vector;\n        kind=:density, alpha=nothing, num_pp_samples=nothing, mean_pp=true, observed=nothing,\n        observed_rug=false, colors=[:steelblue, :black, :orange], jitter=nothing, \n        legend=true, random_seed=nothing, ppc_group=:posterior)","category":"page"},{"location":"statsplots/#API","page":"StatsPlots.jl","title":"API","text":"","category":"section"},{"location":"statsplots/#MCMCChains.energyplot","page":"StatsPlots.jl","title":"MCMCChains.energyplot","text":"energyplot(chains::Chains; kind=:density, kwargs...)\n\nGenerate an energy plot for the samples in chains.\n\nThe energy plot is a diagnostic tool for HMC-based samplers like NUTS. It displays the distributions of the Hamiltonian energy and the energy transition (error) to diagnose sampler efficiency and identify divergences.\n\nThis plot is only available for chains that contain the :hamiltonian_energy and :hamiltonian_energy_error statistics in their :internals section.\n\nKeywords\n\nkind::Symbol (default: :density): The type of plot to generate. Can be :density or :histogram.\n\n\n\n\n\n","category":"function"},{"location":"statsplots/#MCMCChains.energyplot!","page":"StatsPlots.jl","title":"MCMCChains.energyplot!","text":"energyplot(chains::Chains; kind=:density, kwargs...)\n\nGenerate an energy plot for the samples in chains.\n\nThe energy plot is a diagnostic tool for HMC-based samplers like NUTS. It displays the distributions of the Hamiltonian energy and the energy transition (error) to diagnose sampler efficiency and identify divergences.\n\nThis plot is only available for chains that contain the :hamiltonian_energy and :hamiltonian_energy_error statistics in their :internals section.\n\nKeywords\n\nkind::Symbol (default: :density): The type of plot to generate. Can be :density or :histogram.\n\n\n\n\n\nenergyplot(chains::Chains; kind=:density, kwargs...)\n\nGenerate an energy plot for the samples in chains.\n\nThe energy plot is a diagnostic tool for HMC-based samplers like NUTS. It displays the distributions of the Hamiltonian energy and the energy transition (error) to diagnose sampler efficiency and identify divergences.\n\nThis plot is only available for chains that contain the :hamiltonian_energy and :hamiltonian_energy_error statistics in their :internals section.\n\nKeywords\n\nkind::Symbol (default: :density): The type of plot to generate. Can be :density or :histogram.\n\n\n\n\n\n","category":"function"},{"location":"statsplots/#MCMCChains.ppcplot","page":"StatsPlots.jl","title":"MCMCChains.ppcplot","text":"ppcplot(posterior_chains::Chains, posterior_predictive_chains::Chains, observed_data::Vector; kwargs...)\n\nGenerate a posterior/prior predictive check (PPC) plot comparing observed data with predictive samples.\n\nPPC plots are a key tool for model validation in Bayesian analysis. They help assess whether the model  can reproduce the key features of the observed data by comparing the observed data against samples from  the posterior (or prior) predictive distribution.\n\nArguments\n\nposterior_chains::Chains: MCMC samples from the posterior (or prior) distribution\nposterior_predictive_chains::Chains: Samples from the posterior (or prior) predictive distribution\nobserved_data::Vector: The observed data values\n\nKeywords\n\nkind::Symbol (default: :density): Type of plot - :density, :histogram, :scatter, or :cumulative\nalpha::Real (default: 0.2 for density/cumulative, 0.7 for scatter): Transparency of predictive curves\nnum_pp_samples::Integer (default: all samples): Number of predictive samples to plot\nmean_pp::Bool (default: true): Whether to plot the mean of predictive distribution\nobserved::Bool (default: true for posterior, false for prior): Whether to plot observed data\nobserved_rug::Bool (default: false): Whether to add a rug plot for observed data (kde/cumulative only)\ncolors::Vector (default: [:steelblue, :black, :orange]): Colors for [predictive, observed, mean_pp]\njitter::Real (default: 0.0, 0.7 for scatter with ≤5 samples): Jitter amount for scatter plots\nlegend::Bool (default: true): Whether to show legend\nrandom_seed::Integer (default: nothing): Random seed for reproducible subsampling\nppc_group::Symbol (default: :posterior): Specify :posterior or :prior for appropriate defaults and labeling\n\nExamples\n\n# Posterior Predictive Check\nppcplot(posterior_chains, posterior_predictive_chains, observed_data)\n\n# Prior Predictive Check (observed data not shown by default)\nppcplot(prior_chains, prior_predictive_chains, observed_data; ppc_group=:prior)\n\n# Histogram\nppcplot(chains, pp_chains, observed_data; kind=:histogram)\n\n# Cumulative distribution\nppcplot(chains, pp_chains, observed_data; kind=:cumulative)\n\n# Scatter plot with jitter\nppcplot(chains, pp_chains, observed_data; kind=:scatter, jitter=0.5)\n\n# Prior check with observed data shown\nppcplot(prior_chains, pp_chains, observed_data; ppc_group=:prior, observed=true)\n\n# Subset of predictive samples with custom colors\nppcplot(chains, pp_chains, observed_data; \n        num_pp_samples=20, \n        colors=[:blue, :red, :green], \n        random_seed=42)\n\nNotes\n\nThe ppc_group parameter controls default behavior:\n\n:posterior: Shows observed data by default, uses \"Posterior Predictive Check\" title\n:prior: Hides observed data by default, uses \"Prior Predictive Check\" title\n\n\n\n\n\n","category":"function"},{"location":"statsplots/#MCMCChains.ppcplot!","page":"StatsPlots.jl","title":"MCMCChains.ppcplot!","text":"ppcplot(posterior_chains::Chains, posterior_predictive_chains::Chains, observed_data::Vector; kwargs...)\n\nGenerate a posterior/prior predictive check (PPC) plot comparing observed data with predictive samples.\n\nPPC plots are a key tool for model validation in Bayesian analysis. They help assess whether the model  can reproduce the key features of the observed data by comparing the observed data against samples from  the posterior (or prior) predictive distribution.\n\nArguments\n\nposterior_chains::Chains: MCMC samples from the posterior (or prior) distribution\nposterior_predictive_chains::Chains: Samples from the posterior (or prior) predictive distribution\nobserved_data::Vector: The observed data values\n\nKeywords\n\nkind::Symbol (default: :density): Type of plot - :density, :histogram, :scatter, or :cumulative\nalpha::Real (default: 0.2 for density/cumulative, 0.7 for scatter): Transparency of predictive curves\nnum_pp_samples::Integer (default: all samples): Number of predictive samples to plot\nmean_pp::Bool (default: true): Whether to plot the mean of predictive distribution\nobserved::Bool (default: true for posterior, false for prior): Whether to plot observed data\nobserved_rug::Bool (default: false): Whether to add a rug plot for observed data (kde/cumulative only)\ncolors::Vector (default: [:steelblue, :black, :orange]): Colors for [predictive, observed, mean_pp]\njitter::Real (default: 0.0, 0.7 for scatter with ≤5 samples): Jitter amount for scatter plots\nlegend::Bool (default: true): Whether to show legend\nrandom_seed::Integer (default: nothing): Random seed for reproducible subsampling\nppc_group::Symbol (default: :posterior): Specify :posterior or :prior for appropriate defaults and labeling\n\nExamples\n\n# Posterior Predictive Check\nppcplot(posterior_chains, posterior_predictive_chains, observed_data)\n\n# Prior Predictive Check (observed data not shown by default)\nppcplot(prior_chains, prior_predictive_chains, observed_data; ppc_group=:prior)\n\n# Histogram\nppcplot(chains, pp_chains, observed_data; kind=:histogram)\n\n# Cumulative distribution\nppcplot(chains, pp_chains, observed_data; kind=:cumulative)\n\n# Scatter plot with jitter\nppcplot(chains, pp_chains, observed_data; kind=:scatter, jitter=0.5)\n\n# Prior check with observed data shown\nppcplot(prior_chains, pp_chains, observed_data; ppc_group=:prior, observed=true)\n\n# Subset of predictive samples with custom colors\nppcplot(chains, pp_chains, observed_data; \n        num_pp_samples=20, \n        colors=[:blue, :red, :green], \n        random_seed=42)\n\nNotes\n\nThe ppc_group parameter controls default behavior:\n\n:posterior: Shows observed data by default, uses \"Posterior Predictive Check\" title\n:prior: Hides observed data by default, uses \"Prior Predictive Check\" title\n\n\n\n\n\nppcplot(posterior_chains::Chains, posterior_predictive_chains::Chains, observed_data::Vector; kwargs...)\n\nGenerate a posterior/prior predictive check (PPC) plot comparing observed data with predictive samples.\n\nPPC plots are a key tool for model validation in Bayesian analysis. They help assess whether the model  can reproduce the key features of the observed data by comparing the observed data against samples from  the posterior (or prior) predictive distribution.\n\nArguments\n\nposterior_chains::Chains: MCMC samples from the posterior (or prior) distribution\nposterior_predictive_chains::Chains: Samples from the posterior (or prior) predictive distribution\nobserved_data::Vector: The observed data values\n\nKeywords\n\nkind::Symbol (default: :density): Type of plot - :density, :histogram, :scatter, or :cumulative\nalpha::Real (default: 0.2 for density/cumulative, 0.7 for scatter): Transparency of predictive curves\nnum_pp_samples::Integer (default: all samples): Number of predictive samples to plot\nmean_pp::Bool (default: true): Whether to plot the mean of predictive distribution\nobserved::Bool (default: true for posterior, false for prior): Whether to plot observed data\nobserved_rug::Bool (default: false): Whether to add a rug plot for observed data (kde/cumulative only)\ncolors::Vector (default: [:steelblue, :black, :orange]): Colors for [predictive, observed, mean_pp]\njitter::Real (default: 0.0, 0.7 for scatter with ≤5 samples): Jitter amount for scatter plots\nlegend::Bool (default: true): Whether to show legend\nrandom_seed::Integer (default: nothing): Random seed for reproducible subsampling\nppc_group::Symbol (default: :posterior): Specify :posterior or :prior for appropriate defaults and labeling\n\nExamples\n\n# Posterior Predictive Check\nppcplot(posterior_chains, posterior_predictive_chains, observed_data)\n\n# Prior Predictive Check (observed data not shown by default)\nppcplot(prior_chains, prior_predictive_chains, observed_data; ppc_group=:prior)\n\n# Histogram\nppcplot(chains, pp_chains, observed_data; kind=:histogram)\n\n# Cumulative distribution\nppcplot(chains, pp_chains, observed_data; kind=:cumulative)\n\n# Scatter plot with jitter\nppcplot(chains, pp_chains, observed_data; kind=:scatter, jitter=0.5)\n\n# Prior check with observed data shown\nppcplot(prior_chains, pp_chains, observed_data; ppc_group=:prior, observed=true)\n\n# Subset of predictive samples with custom colors\nppcplot(chains, pp_chains, observed_data; \n        num_pp_samples=20, \n        colors=[:blue, :red, :green], \n        random_seed=42)\n\nNotes\n\nThe ppc_group parameter controls default behavior:\n\n:posterior: Shows observed data by default, uses \"Posterior Predictive Check\" title\n:prior: Hides observed data by default, uses \"Prior Predictive Check\" title\n\n\n\n\n\n","category":"function"},{"location":"statsplots/#MCMCChains.ridgelineplot","page":"StatsPlots.jl","title":"MCMCChains.ridgelineplot","text":"ridgelineplot(chains::Chains[, params::Vector{Symbol}]; kwargs...)\n\nGenerate a ridgeline plot for the samples of the parameters params in chains.\n\nBy default, all parameters are plotted.\n\nKeyword arguments\n\nThe following options are available:\n\nfill_q (default: false) and fill_hpd (default: true): Fill the area below the curve in the quantiles interval (fill_q = true) or the highest posterior density (HPD) interval (fill_hpd = true). If both fill_q = false and fill_hpd = false, then the whole area below the curve is filled. If no fill color is desired, it should be specified with series attributes. These options are mutually exclusive.\nshow_mean (default: true) and show_median (default: true): Plot a vertical line of the mean (show_mean = true) or median (show_median = true) of the posterior density estimate. If both options are set to true, both lines are plotted.\nshow_qi (default: false) and show_hpdi (default: true): Plot a quantile interval (show_qi = true) or the largest HPD interval (show_hpdi = true) at the bottom of each density plot. These options are mutually exclusive.\nq (default: [0.1, 0.9]): The two quantiles used for plotting if fill_q = true or show_qi = true.\nhpd_val (default: [0.05, 0.2]): The complementary probability mass(es) of the highest posterior density intervals that are plotted if fill_hpd = true or show_hpdi = true.\n\nnote: Note\nIf a single parameter is provided, the generated plot is a density plot with all the elements described above.\n\n\n\n\n\n","category":"function"},{"location":"statsplots/#MCMCChains.ridgelineplot!","page":"StatsPlots.jl","title":"MCMCChains.ridgelineplot!","text":"ridgelineplot(chains::Chains[, params::Vector{Symbol}]; kwargs...)\n\nGenerate a ridgeline plot for the samples of the parameters params in chains.\n\nBy default, all parameters are plotted.\n\nKeyword arguments\n\nThe following options are available:\n\nfill_q (default: false) and fill_hpd (default: true): Fill the area below the curve in the quantiles interval (fill_q = true) or the highest posterior density (HPD) interval (fill_hpd = true). If both fill_q = false and fill_hpd = false, then the whole area below the curve is filled. If no fill color is desired, it should be specified with series attributes. These options are mutually exclusive.\nshow_mean (default: true) and show_median (default: true): Plot a vertical line of the mean (show_mean = true) or median (show_median = true) of the posterior density estimate. If both options are set to true, both lines are plotted.\nshow_qi (default: false) and show_hpdi (default: true): Plot a quantile interval (show_qi = true) or the largest HPD interval (show_hpdi = true) at the bottom of each density plot. These options are mutually exclusive.\nq (default: [0.1, 0.9]): The two quantiles used for plotting if fill_q = true or show_qi = true.\nhpd_val (default: [0.05, 0.2]): The complementary probability mass(es) of the highest posterior density intervals that are plotted if fill_hpd = true or show_hpdi = true.\n\nnote: Note\nIf a single parameter is provided, the generated plot is a density plot with all the elements described above.\n\n\n\n\n\nridgelineplot(chains::Chains[, params::Vector{Symbol}]; kwargs...)\n\nGenerate a ridgeline plot for the samples of the parameters params in chains.\n\nBy default, all parameters are plotted.\n\nKeyword arguments\n\nThe following options are available:\n\nfill_q (default: false) and fill_hpd (default: true): Fill the area below the curve in the quantiles interval (fill_q = true) or the highest posterior density (HPD) interval (fill_hpd = true). If both fill_q = false and fill_hpd = false, then the whole area below the curve is filled. If no fill color is desired, it should be specified with series attributes. These options are mutually exclusive.\nshow_mean (default: true) and show_median (default: true): Plot a vertical line of the mean (show_mean = true) or median (show_median = true) of the posterior density estimate. If both options are set to true, both lines are plotted.\nshow_qi (default: false) and show_hpdi (default: true): Plot a quantile interval (show_qi = true) or the largest HPD interval (show_hpdi = true) at the bottom of each density plot. These options are mutually exclusive.\nq (default: [0.1, 0.9]): The two quantiles used for plotting if fill_q = true or show_qi = true.\nhpd_val (default: [0.05, 0.2]): The complementary probability mass(es) of the highest posterior density intervals that are plotted if fill_hpd = true or show_hpdi = true.\n\nnote: Note\nIf a single parameter is provided, the generated plot is a density plot with all the elements described above.\n\n\n\n\n\n","category":"function"},{"location":"statsplots/#MCMCChains.forestplot","page":"StatsPlots.jl","title":"MCMCChains.forestplot","text":"forestplot(chains::Chains[, params::Vector{Symbol}]; kwargs...)\n\nGenerate a forest or caterpillar plot for the samples of the parameters params in chains.\n\nBy default, all parameters are plotted.\n\nKeyword arguments\n\nordered (default: false): If ordered = false, a forest plot is generated. If ordered = true, a caterpillar plot is generated.\nfill_q (default: false) and fill_hpd (default: true): Fill the area below the curve in the quantiles interval (fill_q = true) or the highest posterior density (HPD) interval (fill_hpd = true). If both fill_q = false and fill_hpd = false, then the whole area below the curve is filled. If no fill color is desired, it should be specified with series attributes. These options are mutually exclusive.\nshow_mean (default: true) and show_median (default: true): Plot a vertical line of the mean (show_mean = true) or median (show_median = true) of the posterior density estimate. If both options are set to true, both lines are plotted.\nshow_qi (default: false) and show_hpdi (default: true): Plot a quantile interval (show_qi = true) or the largest HPD interval (show_hpdi = true) at the bottom of each density plot. These options are mutually exclusive.\nq (default: [0.1, 0.9]): The two quantiles used for plotting if fill_q = true or show_qi = true.\nhpd_val (default: [0.05, 0.2]): The complementary probability mass(es) of the highest posterior density intervals that are plotted if fill_hpd = true or show_hpdi = true.\n\n\n\n\n\n","category":"function"},{"location":"statsplots/#MCMCChains.forestplot!","page":"StatsPlots.jl","title":"MCMCChains.forestplot!","text":"forestplot(chains::Chains[, params::Vector{Symbol}]; kwargs...)\n\nGenerate a forest or caterpillar plot for the samples of the parameters params in chains.\n\nBy default, all parameters are plotted.\n\nKeyword arguments\n\nordered (default: false): If ordered = false, a forest plot is generated. If ordered = true, a caterpillar plot is generated.\nfill_q (default: false) and fill_hpd (default: true): Fill the area below the curve in the quantiles interval (fill_q = true) or the highest posterior density (HPD) interval (fill_hpd = true). If both fill_q = false and fill_hpd = false, then the whole area below the curve is filled. If no fill color is desired, it should be specified with series attributes. These options are mutually exclusive.\nshow_mean (default: true) and show_median (default: true): Plot a vertical line of the mean (show_mean = true) or median (show_median = true) of the posterior density estimate. If both options are set to true, both lines are plotted.\nshow_qi (default: false) and show_hpdi (default: true): Plot a quantile interval (show_qi = true) or the largest HPD interval (show_hpdi = true) at the bottom of each density plot. These options are mutually exclusive.\nq (default: [0.1, 0.9]): The two quantiles used for plotting if fill_q = true or show_qi = true.\nhpd_val (default: [0.05, 0.2]): The complementary probability mass(es) of the highest posterior density intervals that are plotted if fill_hpd = true or show_hpdi = true.\n\n\n\n\n\nforestplot(chains::Chains[, params::Vector{Symbol}]; kwargs...)\n\nGenerate a forest or caterpillar plot for the samples of the parameters params in chains.\n\nBy default, all parameters are plotted.\n\nKeyword arguments\n\nordered (default: false): If ordered = false, a forest plot is generated. If ordered = true, a caterpillar plot is generated.\nfill_q (default: false) and fill_hpd (default: true): Fill the area below the curve in the quantiles interval (fill_q = true) or the highest posterior density (HPD) interval (fill_hpd = true). If both fill_q = false and fill_hpd = false, then the whole area below the curve is filled. If no fill color is desired, it should be specified with series attributes. These options are mutually exclusive.\nshow_mean (default: true) and show_median (default: true): Plot a vertical line of the mean (show_mean = true) or median (show_median = true) of the posterior density estimate. If both options are set to true, both lines are plotted.\nshow_qi (default: false) and show_hpdi (default: true): Plot a quantile interval (show_qi = true) or the largest HPD interval (show_hpdi = true) at the bottom of each density plot. These options are mutually exclusive.\nq (default: [0.1, 0.9]): The two quantiles used for plotting if fill_q = true or show_qi = true.\nhpd_val (default: [0.05, 0.2]): The complementary probability mass(es) of the highest posterior density intervals that are plotted if fill_hpd = true or show_hpdi = true.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"diagnostics/#MCMCDiagnosticTools.discretediag-Tuple{Chains{var\"#s12\", A} where {var\"#s12\"<:Real, A<:(AxisArrays.AxisArray{var\"#s12\", 3})}}","page":"Diagnostics","title":"MCMCDiagnosticTools.discretediag","text":"discretediag(chains::Chains{<:Real}; sections, kwargs...)\n\nDiscrete diagnostic where method can be [:weiss, :hangartner, :DARBOOT, MCBOOT, :billinsgley, :billingsleyBOOT].\n\n\n\n\n\n","category":"method"},{"location":"diagnostics/#MCMCDiagnosticTools.rstar-Tuple{Any, Chains}","page":"Diagnostics","title":"MCMCDiagnosticTools.rstar","text":"rstar(rng=Random.GLOBAL_RNG, classifier, chains::Chains; kwargs...)\n\nCompute the R^* convergence diagnostic of the MCMC chains with the classifier.\n\nThe keyword arguments supported here are the same as those in rstar for arrays of samples and chain indices.\n\nExamples\n\njulia> using MLJBase, MLJDecisionTreeInterface, Statistics\n\njulia> chains = Chains(fill(4.0, 100, 2, 3));\n\nOne can compute the distribution of the R^* statistic with the probabilistic classifier.\n\njulia> distribution = rstar(DecisionTreeClassifier(), chains);\n\njulia> isapprox(mean(distribution), 1; atol=0.1)\ntrue\n\nFor deterministic classifiers, a single R^* statistic is returned.\n\njulia> decisiontree_deterministic = Pipeline(\n           DecisionTreeClassifier();\n           operation=predict_mode,\n       );\n\njulia> value = rstar(decisiontree_deterministic, chains);\n\njulia> isapprox(value, 1; atol=0.2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"diagnostics/#MCMCDiagnosticTools.ess-Tuple{Chains}","page":"Diagnostics","title":"MCMCDiagnosticTools.ess","text":"ess(chains::Chains; duration=compute_duration, kwargs...)\n\nEstimate the effective sample size.\n\nESS per second options include duration=MCMCChains.compute_duration (the default) and duration=MCMCChains.wall_duration.\n\n\n\n\n\n","category":"method"},{"location":"diagnostics/#MCMCDiagnosticTools.ess_rhat-Tuple{Chains}","page":"Diagnostics","title":"MCMCDiagnosticTools.ess_rhat","text":"ess_rhat(chains::Chains; duration=compute_duration, kwargs...)\n\nEstimate the effective sample size and the widehatR diagnostic\n\nESS per second options include duration=MCMCChains.compute_duration (the default) and duration=MCMCChains.wall_duration.\n\n\n\n\n\n","category":"method"},{"location":"diagnostics/#MCMCDiagnosticTools.rhat-Tuple{Chains}","page":"Diagnostics","title":"MCMCDiagnosticTools.rhat","text":"rhat(chains::Chains; kwargs...)\n\nEstimate the widehatR diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"diagnostics/#MCMCDiagnosticTools.mcse-Tuple{Chains}","page":"Diagnostics","title":"MCMCDiagnosticTools.mcse","text":"mcse(chains::Chains; duration=compute_duration, kwargs...)\n\nEstimate the Monte Carlo standard error.\n\n\n\n\n\n","category":"method"},{"location":"modelstats/#Model-selection","page":"Model selection","title":"Model selection","text":"","category":"section"},{"location":"modelstats/","page":"Model selection","title":"Model selection","text":"The methods listed below are defined in src/modelstats.jl.","category":"page"},{"location":"modelstats/#MCMCChains.dic-Tuple{Chains, Function}","page":"Model selection","title":"MCMCChains.dic","text":"dic(chain::Chains, logpdf::Function) -> (DIC, pD)\n\nCompute the deviance information criterion (DIC). (Smaller is better)\n\nNote: DIC assumes that the posterior distribution is approx. multivariate Gaussian and tends to select overfitted models.\n\nReturns:\n\nDIC: The calculated deviance information criterion\npD: The effective number of parameters\n\nUsage:\n\nchn ... # sampling results\nlpfun = function f(chain::Chains) # function to compute the logpdf values\n    niter, nparams, nchains = size(chain)\n    lp = zeros(niter + nchains) # resulting logpdf values\n    for i = 1:nparams\n        lp += map(p -> logpdf( ... , x), Array(chain[:,i,:]))\n    end\n    return lp\nend\n\nDIC, pD = dic(chn, lpfun)\n\n\n\n\n\n","category":"method"},{"location":"stats/#Posterior-statistics","page":"Posterior statistics","title":"Posterior statistics","text":"","category":"section"},{"location":"stats/","page":"Posterior statistics","title":"Posterior statistics","text":"The methods listed below are defined in src/stats.jl.","category":"page"},{"location":"stats/#StatsBase.autocor","page":"Posterior statistics","title":"StatsBase.autocor","text":"autocor(\n    chains;\n    append_chains = true,\n    demean = true,\n    [lags,]\n    kwargs...,\n)\n\nCompute the autocorrelation of each parameter for the chain.\n\nThe default lags are [1, 5, 10, 50], upper-bounded by n - 1 where n is the number of samples used in the estimation.\n\nSetting append_chains=false will return a vector of dataframes containing the autocorrelations for each chain.\n\n\n\n\n\n","category":"function"},{"location":"stats/#DataAPI.describe","page":"Posterior statistics","title":"DataAPI.describe","text":"describe(io, chains[;\n         q = [0.025, 0.25, 0.5, 0.75, 0.975],\n         etype = :bm,\n         kwargs...])\n\nPrint chain metadata, summary statistics, and quantiles. Use describe(chains) for REPL output to stdout, or specify io for other streams (e.g., file output).\n\n\n\n\n\n","category":"function"},{"location":"stats/#Statistics.mean","page":"Posterior statistics","title":"Statistics.mean","text":"mean(chains[, params; kwargs...])\n\nCalculate the mean of a chain.\n\n\n\n\n\n","category":"function"},{"location":"stats/#StatsBase.summarystats","page":"Posterior statistics","title":"StatsBase.summarystats","text":"function summarystats(\n    chains;\n    sections = _default_sections(chains),\n    append_chains= true,\n    autocov_method::AbstractAutocovMethod = AutocovMethod(),\n    maxlag = 250,\n    kwargs...\n)\n\nCompute the mean, standard deviation, Monte Carlo standard error, bulk- and tail- effective sample size, and widehatR diagnostic for each parameter in the chain.\n\nSetting append_chains=false will return a vector of dataframes containing the summary statistics for each chain.\n\nWhen estimating the effective sample size, autocorrelations are computed for at most maxlag lags.\n\n\n\n\n\n","category":"function"},{"location":"stats/#Statistics.quantile","page":"Posterior statistics","title":"Statistics.quantile","text":"quantile(chains[; q = [0.025, 0.25, 0.5, 0.75, 0.975], append_chains = true, kwargs...])\n\nCompute the quantiles for each parameter in the chain.\n\nSetting append_chains=false will return a vector of dataframes containing the quantiles for each chain.\n\n\n\n\n\n","category":"function"},{"location":"stats/#MCMCChains.hpd","page":"Posterior statistics","title":"MCMCChains.hpd","text":"hpd(chn::Chains; alpha::Real=0.05, kwargs...)\n\nReturn the highest posterior density interval representing 1-alpha probability mass.\n\nNote that this will return a single interval and will not return multiple intervals for discontinuous regions.\n\nExamples\n\njulia> val = rand(500, 2, 3);\njulia> chn = Chains(val, [:a, :b]);\n\njulia> hpd(chn)\nHPD\n  parameters     lower     upper \n      Symbol   Float64   Float64 \n\n           a    0.0554    0.9944\n           b    0.0114    0.9460\n\n\n\n\n\n","category":"function"},{"location":"makie/#Makie.jl-plots","page":"Makie.jl","title":"Makie.jl plots","text":"","category":"section"},{"location":"makie/","page":"Makie.jl","title":"Makie.jl","text":"This page shows an example of plotting MCMCChains.jl with Makie.jl. The example is meant to provide an useful basis to build upon. Let's define some random chain and load the required packages:","category":"page"},{"location":"makie/","page":"Makie.jl","title":"Makie.jl","text":"using MCMCChains\n\nchns = Chains(randn(300, 5, 3), [:A, :B, :C, :D, :E])","category":"page"},{"location":"makie/","page":"Makie.jl","title":"Makie.jl","text":"A basic way to visualize the chains is to show the drawn samples at each iteration. Colors depict different chains.","category":"page"},{"location":"makie/","page":"Makie.jl","title":"Makie.jl","text":"using CairoMakie\nCairoMakie.activate!(; type=\"svg\")\n\nparams = names(chns, :parameters)\n\nn_chains = length(chains(chns))\nn_samples = length(chns)\n\nfig = Figure(; resolution=(1_000, 800))\n\nfor (i, param) in enumerate(params)\n    ax = Axis(fig[i, 1]; ylabel=string(param))\n    for chain in 1:n_chains\n        values = chns[:, param, chain]\n        lines!(ax, 1:n_samples, values; label=string(chain))\n    end\n\n    hideydecorations!(ax; label=false)\n    if i < length(params)\n        hidexdecorations!(ax; grid=false)\n    else\n        ax.xlabel = \"Iteration\"\n    end\nend\n\nfig","category":"page"},{"location":"makie/","page":"Makie.jl","title":"Makie.jl","text":"Next, we can add a second row of plots next to it which show the density estimate for these samples:","category":"page"},{"location":"makie/","page":"Makie.jl","title":"Makie.jl","text":"for (i, param) in enumerate(params)\n    ax = Axis(fig[i, 2]; ylabel=string(param))\n    for chain in 1:n_chains\n        values = chns[:, param, chain]\n        density!(ax, values; label=string(chain))\n    end\n\n    hideydecorations!(ax)\n    if i < length(params)\n        hidexdecorations!(ax; grid=false)\n    else\n        ax.xlabel = \"Parameter estimate\"\n    end\nend\n\naxes = [only(contents(fig[i, 2])) for i in 1:length(params)]\nlinkxaxes!(axes...)\n\nfig","category":"page"},{"location":"makie/","page":"Makie.jl","title":"Makie.jl","text":"Finally, let's add a simple legend. Thanks to setting label above, this legend will have the right labels:","category":"page"},{"location":"makie/","page":"Makie.jl","title":"Makie.jl","text":"axislegend(first(axes))\n\nfig","category":"page"},{"location":"gadfly/#Gadfly.jl-plots","page":"Gadfly.jl","title":"Gadfly.jl plots","text":"","category":"section"},{"location":"gadfly/","page":"Gadfly.jl","title":"Gadfly.jl","text":"To plot the Chains via Gadfly.jl, use the DataFrames constructor:","category":"page"},{"location":"gadfly/","page":"Gadfly.jl","title":"Gadfly.jl","text":"using DataFrames\nusing CategoricalArrays\nusing Gadfly\nwrite_svg(path, p; w=6inch, h=4inch) = Gadfly.draw(Gadfly.SVG(path, w, h), p) # hide\nusing MCMCChains\n\nchn = Chains(randn(100, 2, 3), [:A, :B])\ndf = DataFrame(chn)\ndf[!, :chain] = categorical(df.chain)\n\nplot(df, x=:A, color=:chain, Geom.density, Guide.ylabel(\"Density\"))","category":"page"},{"location":"gadfly/#Multiple-parameters","page":"Gadfly.jl","title":"Multiple parameters","text":"","category":"section"},{"location":"gadfly/","page":"Gadfly.jl","title":"Gadfly.jl","text":"Or, to show multiple parameters in one plot, use DataFrames.stack","category":"page"},{"location":"gadfly/","page":"Gadfly.jl","title":"Gadfly.jl","text":"sdf = stack(df, names(chn), variable_name=:parameter)\nfirst(sdf, 5)","category":"page"},{"location":"gadfly/","page":"Gadfly.jl","title":"Gadfly.jl","text":"and Gadfly.Geom.subplot_grid","category":"page"},{"location":"gadfly/","page":"Gadfly.jl","title":"Gadfly.jl","text":"plot(sdf, ygroup=:parameter, x=:value, color=:chain,\n    Geom.subplot_grid(Geom.density), Guide.ylabel(\"Density\"))","category":"page"},{"location":"gadfly/","page":"Gadfly.jl","title":"Gadfly.jl","text":"This is very flexible. For example, we can look at the first two chains only by using DataFrames.filter","category":"page"},{"location":"gadfly/","page":"Gadfly.jl","title":"Gadfly.jl","text":"first_chain = filter([:chain] => c -> c == 1 || c == 2, sdf)\n\nplot(first_chain, xgroup=:parameter, ygroup=:chain, x=:value,\n    Geom.subplot_grid(Geom.density, Guide.xlabel(orientation=:horizontal)),\n    Guide.xlabel(\"Parameter\"), Guide.ylabel(\"Chain\"))","category":"page"},{"location":"gadfly/#Trace","page":"Gadfly.jl","title":"Trace","text":"","category":"section"},{"location":"gadfly/","page":"Gadfly.jl","title":"Gadfly.jl","text":"plot(first_chain, ygroup=:parameter, x=:iteration, y=:value, color=:chain,\n    Geom.subplot_grid(Geom.point), Guide.ylabel(\"Sample value\"))","category":"page"},{"location":"#MCMCChains","page":"MCMCChains","title":"MCMCChains","text":"","category":"section"},{"location":"","page":"MCMCChains","title":"MCMCChains","text":"Implementation of Julia types for summarizing MCMC simulations and utility functions for diagnostics and visualizations.","category":"page"},{"location":"summarize/#Summarize","page":"Summarize","title":"Summarize","text":"","category":"section"},{"location":"summarize/","page":"Summarize","title":"Summarize","text":"The methods listed below are defined in src/summarize.jl.","category":"page"},{"location":"summarize/#MCMCChains.summarize-Tuple{Chains, Vararg{Any}}","page":"Summarize","title":"MCMCChains.summarize","text":"summarize(chains, funs...[; sections, func_names = [], name = \"\", append_chains = true])\n\nSummarize chains in a ChainsDataFrame.\n\nExamples\n\nsummarize(chns) : Complete chain summary\nsummarize(chns[[:parm1, :parm2]]) : Chain summary of selected parameters\nsummarize(chns; sections=[:parameters])  : Chain summary of :parameters section\nsummarize(chns; sections=[:parameters, :internals]) : Chain summary for multiple sections\n\n\n\n\n\n","category":"method"}]
}
